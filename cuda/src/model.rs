/* automatically generated by rust-bindgen 0.59.1 */

#[doc = " The (u,v,w) coordinates of a baseline. There are no units (i.e. these are"]
#[doc = " dimensionless)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UVW {
    pub u: f64,
    pub v: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_UVW() {
    assert_eq!(
        ::std::mem::size_of::<UVW>(),
        24usize,
        concat!("Size of: ", stringify!(UVW))
    );
    assert_eq!(
        ::std::mem::align_of::<UVW>(),
        8usize,
        concat!("Alignment of ", stringify!(UVW))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UVW>())).u as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UVW), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UVW>())).v as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UVW), "::", stringify!(v))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UVW>())).w as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UVW), "::", stringify!(w))
    );
}
#[doc = " The LMN coordinates of a sky-model component."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LMN {
    pub l: f64,
    pub m: f64,
    pub n: f64,
}
#[test]
fn bindgen_test_layout_LMN() {
    assert_eq!(
        ::std::mem::size_of::<LMN>(),
        24usize,
        concat!("Size of: ", stringify!(LMN))
    );
    assert_eq!(
        ::std::mem::align_of::<LMN>(),
        8usize,
        concat!("Alignment of ", stringify!(LMN))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LMN>())).l as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(LMN), "::", stringify!(l))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LMN>())).m as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(LMN), "::", stringify!(m))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LMN>())).n as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(LMN), "::", stringify!(n))
    );
}
#[doc = " Parameters describing a Gaussian (also applicable to shapelets)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GaussianParams {
    pub maj: f64,
    pub min: f64,
    pub pa: f64,
}
#[test]
fn bindgen_test_layout_GaussianParams() {
    assert_eq!(
        ::std::mem::size_of::<GaussianParams>(),
        24usize,
        concat!("Size of: ", stringify!(GaussianParams))
    );
    assert_eq!(
        ::std::mem::align_of::<GaussianParams>(),
        8usize,
        concat!("Alignment of ", stringify!(GaussianParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GaussianParams>())).maj as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GaussianParams),
            "::",
            stringify!(maj)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GaussianParams>())).min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GaussianParams),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GaussianParams>())).pa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GaussianParams),
            "::",
            stringify!(pa)
        )
    );
}
#[doc = " Parameters describing a shapelet coefficient."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShapeletCoeff {
    pub n1: usize,
    pub n2: usize,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_ShapeletCoeff() {
    assert_eq!(
        ::std::mem::size_of::<ShapeletCoeff>(),
        24usize,
        concat!("Size of: ", stringify!(ShapeletCoeff))
    );
    assert_eq!(
        ::std::mem::align_of::<ShapeletCoeff>(),
        8usize,
        concat!("Alignment of ", stringify!(ShapeletCoeff))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShapeletCoeff>())).n1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ShapeletCoeff),
            "::",
            stringify!(n1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShapeletCoeff>())).n2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ShapeletCoeff),
            "::",
            stringify!(n2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShapeletCoeff>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ShapeletCoeff),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " (u,v) coordinates for a shapelet. W isn't used, so we're a bit more efficient"]
#[doc = " by not using UVW."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShapeletUV {
    pub u: f64,
    pub v: f64,
}
#[test]
fn bindgen_test_layout_ShapeletUV() {
    assert_eq!(
        ::std::mem::size_of::<ShapeletUV>(),
        16usize,
        concat!("Size of: ", stringify!(ShapeletUV))
    );
    assert_eq!(
        ::std::mem::align_of::<ShapeletUV>(),
        8usize,
        concat!("Alignment of ", stringify!(ShapeletUV))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShapeletUV>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ShapeletUV),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ShapeletUV>())).v as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ShapeletUV),
            "::",
            stringify!(v)
        )
    );
}
#[doc = " A Jones matrix, single precision. The floats are unpacked into real and imag"]
#[doc = " components because complex numbers don't traverse the FFI boundary well."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JonesF32 {
    pub xx_re: f32,
    pub xx_im: f32,
    pub xy_re: f32,
    pub xy_im: f32,
    pub yx_re: f32,
    pub yx_im: f32,
    pub yy_re: f32,
    pub yy_im: f32,
}
#[test]
fn bindgen_test_layout_JonesF32() {
    assert_eq!(
        ::std::mem::size_of::<JonesF32>(),
        32usize,
        concat!("Size of: ", stringify!(JonesF32))
    );
    assert_eq!(
        ::std::mem::align_of::<JonesF32>(),
        4usize,
        concat!("Alignment of ", stringify!(JonesF32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).xx_re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(xx_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).xx_im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(xx_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).xy_re as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(xy_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).xy_im as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(xy_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).yx_re as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(yx_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).yx_im as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(yx_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).yy_re as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(yy_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF32>())).yy_im as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF32),
            "::",
            stringify!(yy_im)
        )
    );
}
#[doc = " A Jones matrix, double precision. The floats are unpacked into real and imag"]
#[doc = " components because complex numbers don't traverse the FFI boundary well."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JonesF64 {
    pub xx_re: f64,
    pub xx_im: f64,
    pub xy_re: f64,
    pub xy_im: f64,
    pub yx_re: f64,
    pub yx_im: f64,
    pub yy_re: f64,
    pub yy_im: f64,
}
#[test]
fn bindgen_test_layout_JonesF64() {
    assert_eq!(
        ::std::mem::size_of::<JonesF64>(),
        64usize,
        concat!("Size of: ", stringify!(JonesF64))
    );
    assert_eq!(
        ::std::mem::align_of::<JonesF64>(),
        8usize,
        concat!("Alignment of ", stringify!(JonesF64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).xx_re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(xx_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).xx_im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(xx_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).xy_re as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(xy_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).xy_im as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(xy_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).yx_re as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(yx_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).yx_im as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(yx_im)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).yy_re as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(yy_re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JonesF64>())).yy_im as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JonesF64),
            "::",
            stringify!(yy_im)
        )
    );
}
extern "C" {
    #[doc = " Generate sky-model visibilities for a single timestep given multiple"]
    #[doc = " sky-model point-sources. See the documentation of `model_timestep` for more"]
    #[doc = " info."]
    pub fn model_points(
        num_points: usize,
        point_lmns: *const LMN,
        point_fds: *const JonesF64,
        a: *const Addresses,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate sky-model visibilities for a single timestep given multiple"]
    #[doc = " sky-model Gaussian-sources. See the documentation of `model_timestep` for"]
    #[doc = " more info."]
    pub fn model_gaussians(
        num_gaussians: usize,
        gaussian_lmns: *const LMN,
        gaussian_fds: *const JonesF64,
        gaussian_params: *const GaussianParams,
        a: Addresses,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate sky-model visibilities for a single timestep given multiple"]
    #[doc = " sky-model shapelet-sources. See the documentation of `model_timestep` for"]
    #[doc = " more info."]
    pub fn model_shapelets(
        num_shapelets: usize,
        shapelet_lmns: *const LMN,
        shapelet_fds: *const JonesF64,
        gaussian_params: *const GaussianParams,
        shapelet_uvs: *const ShapeletUV,
        shapelet_coeffs: *const ShapeletCoeff,
        num_shapelet_coeffs: *const usize,
        a: Addresses,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate sky-model visibilities for a single timestep given multiple"]
    #[doc = " sky-model sources."]
    #[doc = ""]
    #[doc = " `uvws` has one element per baseline. `freqs` has one element per..."]
    #[doc = " frequency."]
    #[doc = ""]
    #[doc = " `point_lmns`, `gaussian_lmns` and `shapelet_lmns` are the LMN coordinates for"]
    #[doc = " each sky-model component type."]
    #[doc = ""]
    #[doc = " `point_fds` etc. are two-dimensional arrays, of which the first axis"]
    #[doc = " corresponds to frequency and the second component."]
    #[doc = ""]
    #[doc = " `gaussian_gaussian_params` applies to Gaussian components, whereas"]
    #[doc = " `shapelet_gaussian_params` are for shapelet components."]
    #[doc = ""]
    #[doc = " `shapelet_uvs` are special UVWs (without the Ws) calculated just for the"]
    #[doc = " shapelets. These are two-dimensional arrays; the first axis corresponds to"]
    #[doc = " baselines and the second a shapelet component."]
    #[doc = ""]
    #[doc = " `shapelet_coeffs` is a flattened array-of-arrays. The length of each"]
    #[doc = " sub-array is indicated by `num_shapelet_coeffs` (which has a length equal to"]
    #[doc = " `num_shapelets`)"]
    #[doc = ""]
    #[doc = " `vis` is a two-dimensional array, of which the first axis corresponds to"]
    #[doc = " baselines and the second frequency. It is the only argument that should be"]
    #[doc = " mutated and should be completely full of zeros before this function is"]
    #[doc = " called."]
    pub fn model_timestep(
        num_baselines: usize,
        num_freqs: usize,
        num_points: usize,
        num_gaussians: usize,
        num_shapelets: usize,
        uvws: *const UVW,
        freqs: *const f64,
        point_lmns: *const LMN,
        point_fds: *const JonesF64,
        gaussian_lmns: *const LMN,
        gaussian_fds: *const JonesF64,
        gaussian_gaussian_params: *const GaussianParams,
        shapelet_lmns: *const LMN,
        shapelet_fds: *const JonesF64,
        shapelet_gaussian_params: *const GaussianParams,
        shapelet_uvs: *const ShapeletUV,
        shapelet_coeffs: *const ShapeletCoeff,
        num_shapelet_coeffs: *const usize,
        shapelet_basis_values: *const f64,
        sbf_l: usize,
        sbf_n: usize,
        sbf_c: f64,
        sbf_dx: f64,
        vis: *mut JonesF32,
    ) -> ::std::os::raw::c_int;
}
