// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Integration tests for sky-model visibilities generated by the "simulate-vis"
//! subcommand of hyperdrive.

use approx::assert_abs_diff_eq;
use mwalib::{fitsio_sys, *};
use serial_test::serial;

use crate::*;
use mwa_hyperdrive_common::mwalib;

#[test]
#[serial]
#[allow(clippy::excessive_precision)]
fn test_1090008640_simulate_vis() {
    let num_timesteps = 2;
    let num_chans = 10;

    let mut output_path = TempDir::new().expect("couldn't make tmp dir").into_path();
    output_path.push("model.uvfits");
    let args = get_reduced_1090008640(true, false);

    let cmd = hyperdrive()
        .args(&[
            "simulate-vis",
            "--metafits",
            &args.data.unwrap()[0],
            "--source-list",
            &args.source_list.unwrap(),
            "--output-model-file",
            &format!("{}", output_path.display()),
            "--num-timesteps",
            &format!("{}", num_timesteps),
            "--num-fine-channels",
            &format!("{}", num_chans),
        ])
        .ok();
    assert!(cmd.is_ok(), "{:?}", get_cmd_output(cmd));

    // Test some metadata.
    let mut uvfits = fits_open!(&output_path).unwrap();
    let hdu = fits_open_hdu!(&mut uvfits, 0).unwrap();
    let gcount: String = get_required_fits_key!(&mut uvfits, &hdu, "GCOUNT").unwrap();
    let pcount: String = get_required_fits_key!(&mut uvfits, &hdu, "PCOUNT").unwrap();
    let floats_per_pol: String = get_required_fits_key!(&mut uvfits, &hdu, "NAXIS2").unwrap();
    let num_pols: String = get_required_fits_key!(&mut uvfits, &hdu, "NAXIS3").unwrap();
    let num_fine_freq_chans: String = get_required_fits_key!(&mut uvfits, &hdu, "NAXIS4").unwrap();
    let jd_zero: String = get_required_fits_key!(&mut uvfits, &hdu, "PZERO5").unwrap();
    let ptype4: String = get_required_fits_key!(&mut uvfits, &hdu, "PTYPE4").unwrap();

    assert_eq!(gcount.parse::<i32>().unwrap(), 16256);
    assert_eq!(pcount.parse::<i32>().unwrap(), 5);
    assert_eq!(floats_per_pol.parse::<i32>().unwrap(), 3);
    assert_eq!(num_pols.parse::<i32>().unwrap(), 4);
    assert_eq!(num_fine_freq_chans.parse::<i32>().unwrap(), 10);
    let jd_zero = jd_zero.parse::<f64>().unwrap();
    assert_abs_diff_eq!(jd_zero, 2.456860500E+06);
    assert_eq!(ptype4, "BASELINE");

    let hdu = fits_open_hdu!(&mut uvfits, 1).unwrap();
    let tile_names: Vec<String> = get_fits_col!(&mut uvfits, &hdu, "ANNAME").unwrap();
    assert_eq!(tile_names.len(), 128);
    assert_eq!(tile_names[0], "Tile011");
    assert_eq!(tile_names[127], "Tile088");

    // Test visibility values.
    fits_open_hdu!(&mut uvfits, 0).unwrap();
    let mut group_params = [0.0; 5];
    let mut vis: Vec<f32> = vec![0.0; 10 * 4 * 3];
    let mut status = 0;
    unsafe {
        fitsio_sys::ffggpe(
            uvfits.as_raw(),           /* I - FITS file pointer                       */
            1,                         /* I - group to read (1 = 1st group)           */
            1,                         /* I - first vector element to read (1 = 1st)  */
            group_params.len() as i64, /* I - number of values to read                */
            group_params.as_mut_ptr(), /* O - array of values that are returned       */
            &mut status,               /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
        fitsio_sys::ffgpve(
            uvfits.as_raw(),  /* I - FITS file pointer                       */
            1,                /* I - group to read (1 = 1st group)           */
            1,                /* I - first vector element to read (1 = 1st)  */
            vis.len() as i64, /* I - number of values to read                */
            0.0,              /* I - value for undefined pixels              */
            vis.as_mut_ptr(), /* O - array of values that are returned       */
            &mut 0,           /* O - set to 1 if any values are null; else 0 */
            &mut status,      /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
    };
    assert_abs_diff_eq!(group_params[0], -1.8129127e-07);
    assert_abs_diff_eq!(group_params[1], -1.6603664e-08);
    assert_abs_diff_eq!(group_params[2], -4.800524e-09);
    assert_abs_diff_eq!(group_params[3], 258.0);
    assert_abs_diff_eq!(group_params[4], -0.15944445);
    assert_abs_diff_eq!(group_params[4] as f64 + jd_zero, 2456860.3405555487);

    assert_abs_diff_eq!(vis[0], 36.808147);
    assert_abs_diff_eq!(vis[1], -37.754723);
    assert_abs_diff_eq!(vis[2], 1.0);
    assert_abs_diff_eq!(vis[21], 0.13933058);
    assert_abs_diff_eq!(vis[22], -0.07537054);
    assert_abs_diff_eq!(vis[23], 1.0);

    unsafe {
        fitsio_sys::ffggpe(
            uvfits.as_raw(),           /* I - FITS file pointer                       */
            8129,                      /* I - group to read (1 = 1st group)           */
            1,                         /* I - first vector element to read (1 = 1st)  */
            group_params.len() as i64, /* I - number of values to read                */
            group_params.as_mut_ptr(), /* O - array of values that are returned       */
            &mut status,               /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
        fitsio_sys::ffgpve(
            uvfits.as_raw(),  /* I - FITS file pointer                       */
            8129,             /* I - group to read (1 = 1st group)           */
            1,                /* I - first vector element to read (1 = 1st)  */
            vis.len() as i64, /* I - number of values to read                */
            0.0,              /* I - value for undefined pixels              */
            vis.as_mut_ptr(), /* O - array of values that are returned       */
            &mut 0,           /* O - set to 1 if any values are null; else 0 */
            &mut status,      /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
    };

    assert_abs_diff_eq!(group_params[0], -1.8129812e-07);
    assert_abs_diff_eq!(group_params[1], -1.6555784e-08);
    assert_abs_diff_eq!(group_params[2], -4.7062207e-09);
    assert_abs_diff_eq!(group_params[3], 258.0);
    assert_abs_diff_eq!(group_params[4], -0.15935186);
    assert_abs_diff_eq!(group_params[4] as f64 + jd_zero, 2456860.3406481445);

    assert_abs_diff_eq!(vis[0], 36.86735);
    assert_abs_diff_eq!(vis[1], -37.659954);
    assert_abs_diff_eq!(vis[2], 1.0);
    assert_abs_diff_eq!(vis[21], 0.14030261);
    assert_abs_diff_eq!(vis[22], -0.07559094);
    assert_abs_diff_eq!(vis[23], 1.0);
}
