// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Tests for reading and writing RTS calibration solutions.

use std::io::Cursor;

use approx::assert_abs_diff_eq;
use indoc::indoc;
use marlu::c64;

use super::*;

#[test]
fn test_read_di_jm() {
    let mut contents = Cursor::new(indoc! {"
    16.990089
    -0.131782, -0.933494, +0.019562, +0.135049, -0.008773, -0.134161, -0.063910, -0.921045
    +0.446814, -0.203973, -0.071393, +0.031377, -0.027429, +0.060070, -0.153991, +0.446221
    -0.629691, -0.403369, +0.088931, +0.060120, -0.065456, -0.061017, -0.541366, -0.433762
    "});

    let result = DiJm::read(&mut contents);
    assert!(result.is_ok());
    let di_jm = result.unwrap();

    assert_abs_diff_eq!(di_jm._alignment_flux_density, 16.990089);
    assert_abs_diff_eq!(
        di_jm.post_alignment_matrix,
        Jones::from([
            c64::new(-0.131782, -0.933494),
            c64::new(0.019562, 0.135049),
            c64::new(-0.008773, -0.134161),
            c64::new(-0.063910, -0.921045)
        ])
    );

    assert_eq!(di_jm.pre_alignment_matrices.len(), 2);
    assert_abs_diff_eq!(
        di_jm.pre_alignment_matrices[0],
        Jones::from([
            c64::new(0.446814, -0.203973),
            c64::new(-0.071393, 0.031377),
            c64::new(-0.027429, 0.060070),
            c64::new(-0.153991, 0.446221)
        ])
    );
    assert_abs_diff_eq!(
        di_jm.pre_alignment_matrices[1],
        Jones::from([
            c64::new(-0.629691, -0.403369),
            c64::new(0.088931, 0.060120),
            c64::new(-0.065456, -0.061017),
            c64::new(-0.541366, -0.433762)
        ])
    );
}

#[test]
fn test_read_bad_di_jm() {
    let mut contents = Cursor::new(indoc! {"
    16.990089asdf
    -0.131782, -0.933494, +0.019562, +0.135049, -0.008773, -0.134161, -0.063910, -0.921045
    +0.446814, -0.203973, -0.071393, +0.031377, -0.027429, +0.060070, -0.153991, +0.446221
    -0.629691, -0.403369, +0.088931, +0.060120, -0.065456, -0.061017, -0.541366, -0.433762
    "});
    let result = DiJm::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadDiJmFileError::ParseFloat { .. }),
        "{}",
        err
    );
    match err {
        ReadDiJmFileError::ParseFloat { text, line_num } => {
            assert_eq!(text, "16.990089asdf");
            assert_eq!(line_num, 1);
        }
        _ => unreachable!(),
    }

    // No trailing ", " on line 2.
    let mut contents = Cursor::new(indoc! {"
    16.990089
    -0.131782, -0.933494, +0.019562, +0.135049, -0.008773, -0.134161, -0.063910
    +0.446814, -0.203973, -0.071393, +0.031377, -0.027429, +0.060070, -0.153991, +0.446221
    -0.629691, -0.403369, +0.088931, +0.060120, -0.065456, -0.061017, -0.541366, -0.433762
    "});
    let result = DiJm::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadDiJmFileError::BadFloatCount { .. }),
        "{}",
        err
    );
    match err {
        ReadDiJmFileError::BadFloatCount { count, line_num } => {
            assert_eq!(count, 7);
            assert_eq!(line_num, 2);
        }
        _ => unreachable!(),
    }

    // Trailing ", " on line 3.
    let mut contents = Cursor::new(indoc! {"
    16.990089
    -0.131782, -0.933494, +0.019562, +0.135049, -0.008773, -0.134161, -0.063910, -0.921045
    +0.446814, -0.203973, -0.071393, +0.031377, -0.027429, +0.060070, -0.153991, 
    -0.629691, -0.403369, +0.088931, +0.060120, -0.065456, -0.061017, -0.541366, -0.433762
    "});
    let result = DiJm::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadDiJmFileError::ParseFloat { .. }),
        "{}",
        err
    );
    match err {
        ReadDiJmFileError::ParseFloat { text, line_num } => {
            assert_eq!(text, "");
            assert_eq!(line_num, 3);
        }
        _ => unreachable!(),
    }

    // No pre-alignment matrices.
    let mut contents = Cursor::new(indoc! {"
    16.990089
    -0.131782, -0.933494, +0.019562, +0.135049, -0.008773, -0.134161, -0.063910, -0.921045
    "});
    let result = DiJm::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadDiJmFileError::NoPreAlignmentMatrices),
        "{}",
        err
    );

    // No post-alignment matrix. Right now this returns the "no
    // pre-alignment matrices" error; probably not worth handling this case
    // explicitly.
    let mut contents = Cursor::new(indoc! {"
    16.990089
    "});
    let result = DiJm::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadDiJmFileError::NoPreAlignmentMatrices),
        "{}",
        err
    );
}

#[test]
fn test_read_bp_cal() {
    let mut contents = Cursor::new(indoc! {"
    0.080000, 0.120000, 0.160000, 0.200000, 0.240000, 0.280000, 0.320000, 0.360000, 0.400000, 0.440000, 0.480000, 0.520000, 0.560000, 0.600000, 0.680000, 0.720000, 0.760000, 0.800000, 0.840000, 0.880000, 0.920000, 0.960000, 1.000000, 1.040000, 1.080000, 1.120000, 1.160000
    1, +0.933187,+0.124900, +0.925032,+0.051076, +0.983015,+0.048851, +0.955646,+0.097522, +0.935120,+0.061026, +0.963394,+0.051962, +0.945503,+0.082745, +0.976258,+0.056123, +0.942418,+0.051028, +0.979208,+0.108845, +1.044598,-0.031548, +0.988058,+0.061238, +1.017325,+0.075034, +1.027989,+0.038516, +0.941412,+0.022692, +1.010886,-0.002624, +1.050987,-0.038793, +0.989869,-0.021682, +1.059668,-0.062062, +1.006765,-0.012929, +1.018207,-0.020751, +1.027608,-0.066085, +0.978486,+0.017073, +0.983055,-0.061753, +1.039269,-0.060553, +0.996899,-0.032193, +0.958020,-0.012022
    1, +0.935630,+0.074762, +0.939763,+0.078459, +0.944358,+0.080163, +0.949325,+0.080063, +0.954583,+0.078350, +0.960059,+0.075213, +0.965683,+0.070840, +0.971389,+0.065411, +0.977109,+0.059103, +0.982775,+0.052089, +0.988317,+0.044533, +0.993660,+0.036593, +0.998725,+0.028422, +1.003430,+0.020165, +1.011402,+0.003949, +1.014479,-0.003744, +1.016817,-0.010991, +1.018312,-0.017666, +1.018855,-0.023646, +1.018336,-0.028807, +1.016647,-0.033019, +1.013676,-0.036152, +1.009314,-0.038063, +1.003456,-0.038600, +0.996001,-0.037597, +0.986856,-0.034867, +0.975938,-0.030198
    1, +0.028094,+1.938599, +0.095979,+1.927272, +0.063084,+1.497334, +0.038923,+2.038567, +0.042106,-0.197279, +0.033726,+0.694516, +0.021041,+0.806852, +0.005429,+0.724472, +0.024595,+1.080244, +0.064542,-1.462700, +0.007677,+3.062105, +0.042752,+2.964023, +0.024250,+1.750612, +0.025183,+0.572852, +0.093246,-1.437371, +0.072960,+0.388607, +0.036465,-2.293088, +0.051817,-0.380447, +0.061873,+0.746348, +0.057017,-3.012728, +0.017769,-1.969344, +0.034354,+1.581927, +0.014601,-2.095187, +0.014736,-1.062069, +0.022657,+2.769590, +0.039287,+2.177993, +0.023057,-1.619737
    1, +0.066164,+1.748954, +0.052874,+1.719049, +0.041183,+1.675159, +0.031050,+1.608016, +0.022479,+1.499359, +0.015579,+1.311149, +0.010716,+0.971955, +0.008587,+0.448632, +0.009110,-0.044585, +0.010768,-0.343075, +0.012416,-0.504872, +0.013631,-0.594778, +0.014297,-0.645468, +0.014406,-0.672629, +0.013112,-0.684532, +0.011819,-0.675930, +0.010177,-0.659721, +0.008246,-0.636544, +0.006085,-0.606553, +0.003749,-0.569295, +0.001286,-0.520642, +0.001264,+2.653342, +0.003872,+2.716903, +0.006523,+2.783537, +0.009220,+2.857618, +0.011984,+2.939568, +0.014863,+3.029070
    1, +0.047613,-0.953055, +0.049172,-0.356952, +0.061236,+0.828989, +0.033252,-1.788378, +0.045302,+1.363646, +0.073906,+2.367618, +0.042014,+1.276348, +0.032000,-0.278429, +0.043980,-2.598768, +0.026952,-1.163291, +0.074998,-2.961170, +0.036996,-3.010257, +0.028327,-0.023353, +0.057924,-1.023675, +0.053567,+1.775871, +0.050446,+1.753041, +0.037429,-0.475048, +0.062293,-0.523358, +0.045817,-0.723847, +0.019351,-1.901438, +0.021662,-1.067652, +0.082240,+3.042886, +0.065688,-2.205149, +0.033271,-1.403604, +0.029344,+0.832091, +0.028224,+1.130839, +0.069914,+1.782797
    1, +0.043069,-0.456759, +0.028309,-0.292615, +0.017425,+0.014971, +0.011482,+0.601228, +0.011186,+1.289382, +0.013345,+1.706096, +0.015128,+1.934912, +0.015756,+2.088093, +0.015177,+2.217934, +0.013567,+2.356820, +0.011234,+2.541970, +0.008703,+2.841048, +0.007012,-2.926967, +0.007569,-2.296864, +0.013472,-1.632345, +0.016695,-1.494674, +0.019369,-1.405565, +0.021161,-1.342770, +0.021782,-1.295255, +0.020963,-1.256669, +0.018444,-1.222178, +0.013970,-1.184827, +0.007298,-1.114349, +0.002049,+1.552699, +0.013793,+1.896750, +0.028622,+1.938191, +0.046677,+1.959530
    1, +0.965535,+0.056896, +0.961423,+0.031604, +0.918322,+0.087380, +0.957804,+0.021935, +0.991440,+0.129885, +0.962293,+0.093485, +0.945119,+0.015435, +0.995737,+0.041320, +0.999693,+0.108345, +0.910748,+0.090467, +1.012052,+0.110794, +0.997660,+0.006490, +1.038891,+0.086169, +1.048333,-0.014283, +1.077019,+0.013320, +0.953071,-0.032596, +0.969127,+0.024367, +1.013380,-0.081947, +0.947049,-0.001318, +0.958080,-0.009211, +0.966176,-0.039651, +1.009018,-0.060612, +0.959023,-0.054578, +0.996081,-0.024407, +1.047672,-0.056903, +0.972460,-0.042379, +1.071203,-0.062889
    1, +0.930994,+0.042934, +0.944591,+0.055716, +0.956214,+0.065144, +0.965938,+0.071606, +0.973868,+0.075439, +0.980136,+0.076930, +0.984891,+0.076338, +0.988296,+0.073893, +0.990522,+0.069810, +0.991747,+0.064288, +0.992150,+0.057523, +0.991912,+0.049707, +0.991207,+0.041031, +0.990211,+0.031692, +0.987998,+0.011834, +0.987094,+0.001737, +0.986518,-0.008178, +0.986403,-0.017685, +0.986877,-0.026552, +0.988060,-0.034543, +0.990064,-0.041426, +0.993002,-0.046970, +0.996985,-0.050950, +1.002125,-0.053153, +1.008544,-0.053382, +1.016374,-0.051455, +1.025759,-0.047216
    "});

    let result = BpCal::read(&mut contents);
    assert!(result.is_ok(), "{}", result.unwrap_err());
    let bp_cal = result.unwrap();

    assert!(bp_cal.fine_channel_resolution.is_some());
    assert_abs_diff_eq!(bp_cal.fine_channel_resolution.unwrap(), 40e3);
    assert_abs_diff_eq!(
        array![
            2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
            27, 28, 29
        ],
        Array1::from(bp_cal.unflagged_fine_channel_indices.into_vec())
    );

    assert_eq!(bp_cal.data.dim().0, 1); // One tile
    assert_eq!(bp_cal.data.dim().1, 2); // "lsq" and "fit" data
    assert_eq!(bp_cal.data.dim().2, 27); // 27 unflagged channels

    assert_abs_diff_eq!(
        bp_cal.data[(0, 0, 0)],
        Jones::from([
            Complex::from_polar(0.933187, 0.124900),
            Complex::from_polar(0.028094, 1.938599),
            Complex::from_polar(0.047613, -0.953055),
            Complex::from_polar(0.965535, 0.056896)
        ])
    );
    assert_abs_diff_eq!(
        bp_cal.data[(0, 1, 0)],
        Jones::from([
            Complex::from_polar(0.935630, 0.074762),
            Complex::from_polar(0.066164, 1.748954),
            Complex::from_polar(0.043069, -0.456759),
            Complex::from_polar(0.930994, 0.042934)
        ])
    );

    assert_abs_diff_eq!(
        bp_cal.data[(0, 0, 1)],
        Jones::from([
            Complex::from_polar(0.925032, 0.051076),
            Complex::from_polar(0.095979, 1.927272),
            Complex::from_polar(0.049172, -0.356952),
            Complex::from_polar(0.961423, 0.031604)
        ])
    );
    assert_abs_diff_eq!(
        bp_cal.data[(0, 1, 1)],
        Jones::from([
            Complex::from_polar(0.939763, 0.078459),
            Complex::from_polar(0.052874, 1.719049),
            Complex::from_polar(0.028309, -0.292615),
            Complex::from_polar(0.944591, 0.055716)
        ])
    );

    assert_abs_diff_eq!(
        bp_cal.data[(0, 0, 26)],
        Jones::from([
            Complex::from_polar(0.958020, -0.012022),
            Complex::from_polar(0.023057, -1.619737),
            Complex::from_polar(0.069914, 1.782797),
            Complex::from_polar(1.071203, -0.062889)
        ])
    );
    assert_abs_diff_eq!(
        bp_cal.data[(0, 1, 26)],
        Jones::from([
            Complex::from_polar(0.975938, -0.030198),
            Complex::from_polar(0.014863, 3.029070),
            Complex::from_polar(0.046677, 1.959530),
            Complex::from_polar(1.025759, -0.047216)
        ])
    );
}

#[test]
fn test_read_bad_bp_cal() {
    let mut contents = Cursor::new(indoc! {"
    0.080000, 0.120000, 0.160000, 0.200000, 0.240000, 0.280000, 0.320000, 0.360000, 0.400000, 0.440000, 0.480000, 0.520000, 0.560000, 0.600000, 0.680000, 0.720000, 0.760000, 0.800000, 0.840000, 0.880000, 0.920000, 0.960000, 1.000000, 1.040000, 1.080000, 1.120000, asdf
    "});

    let result = BpCal::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        // Even though there's a bad float, the number of lines is checked
        // first.
        matches!(err, ReadBpCalFileError::NoTiles),
        "{}",
        err
    );

    let mut contents = Cursor::new(indoc! {"
    0.080000, 0.120000, 0.160000, 0.200000, 0.240000, 0.280000, 0.320000, 0.360000, 0.400000, 0.440000, 0.480000, 0.520000, 0.560000, 0.600000, 0.680000, 0.720000, 0.760000, 0.800000, 0.840000, 0.880000, 0.920000, 0.960000, 1.000000, 1.040000, 1.080000, 1.120000
    "});

    let result = BpCal::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(matches!(err, ReadBpCalFileError::NoTiles), "{}", err);

    let mut contents = Cursor::new(indoc! {"
    0.080000, 0.120000, 0.160000, 0.200000, 0.240000, 0.280000, 0.320000, 0.360000, 0.400000, 0.440000, 0.480000, 0.520000, 0.560000, 0.600000, 0.680000, 0.720000, 0.760000, 0.800000, 0.840000, 0.880000, 0.920000, 0.960000, 1.000000, 1.040000, 1.080000, 1.120000,
    1, +0.933187,+0.124900, +0.925032,+0.051076, +0.983015,+0.048851, +0.955646,+0.097522, +0.935120,+0.061026, +0.963394,+0.051962, +0.945503,+0.082745, +0.976258,+0.056123, +0.942418,+0.051028, +0.979208,+0.108845, +1.044598,-0.031548, +0.988058,+0.061238, +1.017325,+0.075034, +1.027989,+0.038516, +0.941412,+0.022692, +1.010886,-0.002624, +1.050987,-0.038793, +0.989869,-0.021682, +1.059668,-0.062062, +1.006765,-0.012929, +1.018207,-0.020751, +1.027608,-0.066085, +0.978486,+0.017073, +0.983055,-0.061753, +1.039269,-0.060553, +0.996899,-0.032193, +0.958020,-0.012022
    "});

    let result = BpCal::read(&mut contents);
    assert!(result.is_err());
    let err = result.unwrap_err();
    assert!(
        matches!(err, ReadBpCalFileError::UnexpectedLineCount { .. }),
        "{}",
        err
    );
    match err {
        ReadBpCalFileError::UnexpectedLineCount { got } => {
            assert_eq!(got, 2);
        }
        _ => unreachable!(),
    }
}
