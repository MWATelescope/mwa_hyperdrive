// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Integration tests for sky-model visibilities generated by the "vis-simulate"
//! subcommand of hyperdrive.

use std::path::Path;

use approx::assert_abs_diff_eq;
use clap::Parser;
use marlu::{uvfits::decode_uvfits_baseline, XyzGeodetic, ENH};
use mwalib::{MetafitsContext, Pol};
use serial_test::serial;
use tempfile::TempDir;

use crate::{
    cli::vis_simulate::VisSimulateArgs,
    io::read::fits::{fits_get_col, fits_get_required_key, fits_open, fits_open_hdu},
    tests::{get_reduced_1090008640_raw, DataAsStrings},
};

fn get_reduced_1090008640(
    use_fee_beam: bool,
    use_autos: bool,
    num_chans: usize,
    num_timesteps: usize,
    output_path: &Path,
) -> VisSimulateArgs {
    let DataAsStrings {
        metafits, srclist, ..
    } = get_reduced_1090008640_raw();
    let beam_type = {
        if use_fee_beam {
            "fee"
        } else {
            "none"
        }
    };

    let output_model_files = format!("{}", output_path.display());
    let num_timesteps_str = format!("{num_timesteps}");
    let num_chans_str = format!("{num_chans}");

    #[rustfmt::skip]
    let mut argv = vec![
        "vis-simulate",
        "--metafits", &metafits,
        "--source-list", &srclist,
        "--beam-type", &beam_type,
        "--output-model-files", &output_model_files,
        "--num-timesteps", &num_timesteps_str,
        "--num-fine-channels", &num_chans_str,
        "--veto-threshold", "0.0", // Don't complicate things with vetoing
    ];
    if use_autos {
        argv.push("--output-autos");
    }
    VisSimulateArgs::parse_from(argv)
}

fn read_uvfits_stabxyz(
    fptr: &mut fitsio::FitsFile,
    _hdu: &fitsio::hdu::FitsHdu,
    num_tiles: usize,
) -> Vec<XyzGeodetic> {
    unsafe {
        // With the column name, get the column number.
        let mut status = 0;
        let mut col_num = -1;
        let keyword = std::ffi::CString::new("STABXYZ").unwrap();
        // ffgcno = fits_get_colnum
        fitsio_sys::ffgcno(
            fptr.as_raw(),
            0,
            keyword.as_ptr() as *mut std::os::raw::c_char,
            &mut col_num,
            &mut status,
        );
        assert_eq!(status, 0, "Status wasn't 0");

        // Now get the column data.
        let mut array = vec![XyzGeodetic::default(); num_tiles];
        let array_ptr = array.as_mut_ptr();
        // ffgcv = fits_read_col
        fitsio_sys::ffgcv(
            fptr.as_raw(),
            82, // TDOUBLE
            col_num,
            1,
            1,
            (num_tiles * 3) as i64,
            std::ptr::null_mut(),
            array_ptr as *mut core::ffi::c_void,
            &mut 0,
            &mut status,
        );
        assert_eq!(status, 0, "Status wasn't 0");
        array
    }
}

#[test]
#[serial]
/// Test that the vis-simulate command works for both auto and cross-correlations.
/// cargo test --release -- cli::vis_simulate::tests::test_1090008640_vis_simulate_autos --exact --show-output
fn test_1090008640_vis_simulate_autos() {
    let num_timesteps = 2;
    let num_chans = 2;

    for use_autos in [true, false] {
        let temp_dir = TempDir::new().expect("couldn't make tmp dir");
        let output_path = temp_dir.path().join("model.uvfits");
        let sim_args =
            get_reduced_1090008640(false, use_autos, num_chans, num_timesteps, &output_path);
        let metafits = sim_args.simulate_args.metafits.as_ref().unwrap().clone();

        // Run vis-simulate and check that it succeeds
        let result = sim_args.run(false);
        assert!(result.is_ok(), "result={:?} not ok", result.err().unwrap());

        // Test some metadata. Compare with the input metafits file.
        let metafits = MetafitsContext::new(&metafits, None).unwrap();
        let mut uvfits = fits_open(&output_path).unwrap();
        let hdu0 = fits_open_hdu(&mut uvfits, 0).unwrap();
        let gcount: String = fits_get_required_key(&mut uvfits, &hdu0, "GCOUNT").unwrap();
        let pcount: String = fits_get_required_key(&mut uvfits, &hdu0, "PCOUNT").unwrap();
        let floats_per_pol: String = fits_get_required_key(&mut uvfits, &hdu0, "NAXIS2").unwrap();
        let num_pols: String = fits_get_required_key(&mut uvfits, &hdu0, "NAXIS3").unwrap();
        let num_fine_freq_chans: String =
            fits_get_required_key(&mut uvfits, &hdu0, "NAXIS4").unwrap();
        let jd_zero: String = fits_get_required_key(&mut uvfits, &hdu0, "PZERO5").unwrap();
        let ptype4: String = fits_get_required_key(&mut uvfits, &hdu0, "PTYPE4").unwrap();

        let pcount: usize = pcount.parse().unwrap();
        assert_eq!(pcount, 7);

        assert_eq!(floats_per_pol.parse::<i32>().unwrap(), 3);
        assert_eq!(num_pols.parse::<i32>().unwrap(), 4);
        assert_eq!(
            num_fine_freq_chans.parse::<i32>().unwrap(),
            num_chans as i32
        );
        let jd_zero = jd_zero.parse::<f64>().unwrap();
        assert_abs_diff_eq!(jd_zero, 2.456860500E+06);
        assert_eq!(ptype4, "BASELINE");

        let hdu1 = fits_open_hdu(&mut uvfits, 1).unwrap();
        let tile_names: Vec<String> = fits_get_col(&mut uvfits, &hdu1, "ANNAME").unwrap();
        assert_eq!(tile_names.len(), 128);
        assert_eq!(tile_names[0], "Tile011");
        assert_eq!(tile_names[1], "Tile012");
        assert_eq!(tile_names[127], "Tile168");
        for (i, (tile_name, metafits_tile_name)) in tile_names
            .iter()
            .zip(
                metafits
                    .rf_inputs
                    .iter()
                    .filter(|rf| rf.pol == Pol::X)
                    .map(|rf| &rf.tile_name),
            )
            .enumerate()
        {
            assert_eq!(tile_name, metafits_tile_name, "Wrong for tile {i}");
        }

        let num_tiles = tile_names.len();
        let mut num_baselines = num_tiles * (num_tiles - 1) / 2;
        if use_autos {
            num_baselines += num_tiles;
        }
        let expected_rows = num_timesteps * num_baselines;
        assert_eq!(gcount.parse::<i32>().unwrap(), expected_rows as i32);

        let tile_positions = read_uvfits_stabxyz(&mut uvfits, &hdu1, num_tiles);
        assert_abs_diff_eq!(tile_positions[0].x, 456.2500494643639);
        assert_abs_diff_eq!(tile_positions[0].y, -149.78500366210938);
        assert_abs_diff_eq!(tile_positions[0].z, 68.04598669887378);
        assert_abs_diff_eq!(tile_positions[10].x, 464.8409142556812);
        assert_abs_diff_eq!(tile_positions[10].y, -123.66699981689453);
        assert_abs_diff_eq!(tile_positions[10].z, 85.0377637878737);
        for (tile_pos, metafits_tile_pos) in tile_positions.into_iter().zip(
            metafits
                .rf_inputs
                .iter()
                .filter(|rf| rf.pol == Pol::X)
                .map(|rf| {
                    ENH {
                        e: rf.east_m,
                        n: rf.north_m,
                        h: rf.height_m,
                    }
                    .to_xyz_mwa()
                }),
        ) {
            assert_abs_diff_eq!(tile_pos.x, metafits_tile_pos.x);
            assert_abs_diff_eq!(tile_pos.y, metafits_tile_pos.y);
            assert_abs_diff_eq!(tile_pos.z, metafits_tile_pos.z);
        }
        drop(hdu1);

        // Test visibility values.
        let hdu0 = fits_open_hdu(&mut uvfits, 0).unwrap();
        let mut group_params = vec![0.0; pcount];
        let mut vis: Vec<f32> = vec![0.0; num_chans * 4 * 3];
        let mut status = 0;
        unsafe {
            // ffggpe = fits_read_grppar_flt
            fitsio_sys::ffggpe(
                uvfits.as_raw(),           /* I - FITS file pointer                       */
                1,                         /* I - group to read (1 = 1st group)           */
                1,                         /* I - first vector element to read (1 = 1st)  */
                group_params.len() as i64, /* I - number of values to read                */
                group_params.as_mut_ptr(), /* O - array of values that are returned       */
                &mut status,               /* IO - error status                           */
            );
            assert_eq!(status, 0, "Status wasn't 0");
            // ffgpve = fits_read_img_flt
            fitsio_sys::ffgpve(
                uvfits.as_raw(),  /* I - FITS file pointer                       */
                1,                /* I - group to read (1 = 1st group)           */
                1,                /* I - first vector element to read (1 = 1st)  */
                vis.len() as i64, /* I - number of values to read                */
                0.0,              /* I - value for undefined pixels              */
                vis.as_mut_ptr(), /* O - array of values that are returned       */
                &mut 0,           /* O - set to 1 if any values are null; else 0 */
                &mut status,      /* IO - error status                           */
            );
            assert_eq!(status, 0, "Status wasn't 0");
        };

        // check first group params and vis
        let (a1, a2) = decode_uvfits_baseline(group_params[3] as usize);
        assert_abs_diff_eq!(group_params[4] as f64 + jd_zero, 2456860.3406018466);

        if use_autos {
            assert_eq!(a1, a2, "first vis should be auto-correlation");
            assert_abs_diff_eq!(
                group_params[..],
                [0.0, 0.0, 0.0, 257.0, -0.15939815, 5.276111e-9, 8.0]
            );
            assert_abs_diff_eq!(vis[..3], [525.2498, 0.0, 64.0]);
        } else {
            assert_ne!(a1, a2, "first vis should be cross-correlation");
            assert_abs_diff_eq!(
                group_params[..],
                [
                    -1.812924e-7,
                    -1.6595452e-8,
                    -4.7857687e-9,
                    258.0,
                    -0.15939815,
                    5.276111e-9,
                    8.0
                ]
            );
            assert_abs_diff_eq!(vis[..3], [74.62623, -66.97426, 64.0]);
        }

        // now read the last row
        unsafe {
            // ffggpe = fits_read_grppar_flt
            fitsio_sys::ffggpe(
                uvfits.as_raw(),           /* I - FITS file pointer                       */
                expected_rows as i64,      /* I - group to read (1 = 1st group)           */
                1,                         /* I - first vector element to read (1 = 1st)  */
                group_params.len() as i64, /* I - number of values to read                */
                group_params.as_mut_ptr(), /* O - array of values that are returned       */
                &mut status,               /* IO - error status                           */
            );
            assert_eq!(status, 0, "Status wasn't 0");
            // ffgpve = fits_read_img_flt
            fitsio_sys::ffgpve(
                uvfits.as_raw(),      /* I - FITS file pointer                       */
                expected_rows as i64, /* I - group to read (1 = 1st group)           */
                1,                    /* I - first vector element to read (1 = 1st)  */
                vis.len() as i64,     /* I - number of values to read                */
                0.0,                  /* I - value for undefined pixels              */
                vis.as_mut_ptr(),     /* O - array of values that are returned       */
                &mut 0,               /* O - set to 1 if any values are null; else 0 */
                &mut status,          /* IO - error status                           */
            );
            assert_eq!(status, 0, "Status wasn't 0");
        };
        drop(hdu0);
        drop(uvfits);

        let (a1, a2) = decode_uvfits_baseline(group_params[3] as usize);
        if use_autos {
            assert_eq!(a1, a2, "last vis should be auto-correlation");
            assert_abs_diff_eq!(
                group_params[..],
                [0.0, 0.0, 0.0, 32896.0, -0.15930556, 2.053044e-9, 8.0]
            );
            assert_abs_diff_eq!(vis[..3], [525.2498, 0.0, 64.0]);
        } else {
            assert_ne!(a1, a2, "last vis should be cross-correlation");
            assert_abs_diff_eq!(
                group_params[..],
                [
                    -2.1892085e-7,
                    2.921915e-7,
                    -4.444021e-9,
                    32640.0,
                    -0.15930556,
                    2.053044e-9,
                    8.0
                ]
            );
            assert_abs_diff_eq!(vis[..3], [49.50796, -27.78015, 64.0]);
        }
    }
}

// Ensure that visibilities generated by double-precision CUDA and the CPU are
// exactly the same.
#[test]
#[serial]
#[cfg(all(any(feature = "cuda", feature = "hip"), not(feature = "gpu-single")))]
fn test_1090008640_vis_simulate_cpu_gpu_match() {
    use ndarray::prelude::*;

    let num_timesteps = 2;
    let num_chans = 5;

    let temp_dir = TempDir::new().expect("couldn't make tmp dir");
    let output_path = temp_dir.path().join("model.uvfits");
    let args = get_reduced_1090008640(false, false, num_chans, num_timesteps, &output_path);
    let metafits = args.simulate_args.metafits.as_ref().unwrap().clone();
    #[rustfmt::skip]
    let sim_args = VisSimulateArgs::parse_from([
        "vis-simulate",
        "--metafits", &metafits.display().to_string(),
        "--source-list", &args.srclist_args.source_list.unwrap(),
        "--output-model-files", &output_path.display().to_string(),
        "--num-timesteps", &format!("{num_timesteps}"),
        "--num-fine-channels", &format!("{num_chans}"),
        "--cpu",
    ]);
    let result = sim_args.run(false);
    assert!(result.is_ok(), "result={:?} not ok", result.err().unwrap());

    let mut uvfits = fits_open(&output_path).unwrap();
    let hdu = fits_open_hdu(&mut uvfits, 0).unwrap();

    let mut group_params = [0.0; 5];
    let mut vis_cpu = Array4::default((num_timesteps, num_chans, 4, 3));
    let mut status = 0;
    unsafe {
        // ffggpe = fits_read_grppar_flt
        fitsio_sys::ffggpe(
            uvfits.as_raw(),           /* I - FITS file pointer                       */
            1,                         /* I - group to read (1 = 1st group)           */
            1,                         /* I - first vector element to read (1 = 1st)  */
            group_params.len() as i64, /* I - number of values to read                */
            group_params.as_mut_ptr(), /* O - array of values that are returned       */
            &mut status,               /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
        // ffgpve = fits_read_img_flt
        fitsio_sys::ffgpve(
            uvfits.as_raw(),      /* I - FITS file pointer                       */
            1,                    /* I - group to read (1 = 1st group)           */
            1,                    /* I - first vector element to read (1 = 1st)  */
            vis_cpu.len() as i64, /* I - number of values to read                */
            0.0,                  /* I - value for undefined pixels              */
            vis_cpu.as_mut_ptr(), /* O - array of values that are returned       */
            &mut 0,               /* O - set to 1 if any values are null; else 0 */
            &mut status,          /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
    };
    drop(hdu);
    drop(uvfits);

    let args = get_reduced_1090008640(false, false, num_chans, num_timesteps, &output_path);
    let metafits = args.simulate_args.metafits.as_ref().unwrap().clone();
    #[rustfmt::skip]
    let sim_args = VisSimulateArgs::parse_from([
        "vis-simulate",
        "--metafits", &metafits.display().to_string(),
        "--source-list", &args.srclist_args.source_list.unwrap(),
        "--output-model-files", &output_path.display().to_string(),
        "--num-timesteps", &format!("{num_timesteps}"),
        "--num-fine-channels", &format!("{num_chans}"),
    ]);

    // Run vis-simulate and check that it succeeds
    let result = sim_args.run(false);
    assert!(result.is_ok(), "result={:?} not ok", result.err().unwrap());

    let mut uvfits = fits_open(&output_path).unwrap();
    let hdu = fits_open_hdu(&mut uvfits, 0).unwrap();

    let mut vis_gpu = Array4::default((num_timesteps, num_chans, 4, 3));
    unsafe {
        // ffggpe = fits_read_grppar_flt
        fitsio_sys::ffggpe(
            uvfits.as_raw(),           /* I - FITS file pointer                       */
            1,                         /* I - group to read (1 = 1st group)           */
            1,                         /* I - first vector element to read (1 = 1st)  */
            group_params.len() as i64, /* I - number of values to read                */
            group_params.as_mut_ptr(), /* O - array of values that are returned       */
            &mut status,               /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
        // ffgpve = fits_read_img_flt
        fitsio_sys::ffgpve(
            uvfits.as_raw(),      /* I - FITS file pointer                       */
            1,                    /* I - group to read (1 = 1st group)           */
            1,                    /* I - first vector element to read (1 = 1st)  */
            vis_gpu.len() as i64, /* I - number of values to read                */
            0.0,                  /* I - value for undefined pixels              */
            vis_gpu.as_mut_ptr(), /* O - array of values that are returned       */
            &mut 0,               /* O - set to 1 if any values are null; else 0 */
            &mut status,          /* IO - error status                           */
        );
        assert_eq!(status, 0, "Status wasn't 0");
    };
    drop(hdu);
    drop(uvfits);

    assert_abs_diff_eq!(vis_cpu, vis_gpu, epsilon = 1e-5);
}
