// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Handle source list files.
//!
//! The executable generated by this file can verify that hyperdrive can read
//! source files, as well as convert between supported source list formats.

use std::path::PathBuf;

use structopt::{clap::AppSettings, StructOpt};

use mwa_hyperdrive_srclist::*;

#[derive(StructOpt, Debug)]
#[structopt(name = "hyperdrive srclist", author, about,
            global_settings = &[AppSettings::ColoredHelp,
                                AppSettings::ArgRequiredElseHelp])]
enum Args {
    /// Convert a sky-model source list from one format to another.
    ///
    /// See for more info:
    /// https://github.com/MWATelescope/mwa_hyperdrive/wiki/Source-lists
    Convert {
        #[structopt(short = "i", long, parse(from_str), help = CONVERT_INPUT_TYPE_HELP.as_str())]
        input_type: Option<String>,

        /// Path to the source list to be converted.
        #[structopt(name = "INPUT_SOURCE_LIST", parse(from_os_str))]
        input_source_list: PathBuf,

        #[structopt(short = "o", long, parse(from_str), help = CONVERT_OUTPUT_TYPE_HELP.as_str())]
        output_type: Option<String>,

        /// Path to the output source list. If the file extension is .json or
        /// .yaml, then it will written in the hyperdrive source list format. If
        /// it is .txt, then the --output-type flag should be used to specify
        /// the type of source list to be written.
        #[structopt(name = "OUTPUT_SOURCE_LIST", parse(from_os_str))]
        output_source_list: PathBuf,

        /// The verbosity of the program. The default is to print high-level
        /// information.
        #[structopt(short, long, parse(from_occurrences))]
        verbosity: u8,
    },

    /// Verify that sky-model source lists can be read by hyperdrive.
    ///
    /// See for more info:
    /// https://github.com/MWATelescope/mwa_hyperdrive/wiki/Source-lists
    Verify {
        /// Path to the source list(s) to be verified.
        #[structopt(name = "SOURCE_LISTS", parse(from_os_str))]
        source_lists: Vec<PathBuf>,

        /// The verbosity of the program. The default is to print high-level
        /// information.
        #[structopt(short, long, parse(from_occurrences))]
        verbosity: u8,
    },
}

fn setup_logging(level: u8) -> Result<(), fern::InitError> {
    fern::Dispatch::new()
        .format(|out, message, record| {
            out.finish(format_args!(
                "[{} line {}][{}] {}",
                record.target(),
                record.line().unwrap_or(0),
                record.level(),
                message
            ))
        })
        .level(match level {
            0 => log::LevelFilter::Info,
            1 => log::LevelFilter::Debug,
            _ => log::LevelFilter::Trace,
        })
        .chain(std::io::stdout())
        .apply()?;
    Ok(())
}

fn main() {
    // Stolen from BurntSushi. We don't return Result from main because it
    // prints the debug representation of the error. The code below prints the
    // "display" or human readable representation of the error.
    if let Err(e) = try_main() {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    }
}

fn try_main() -> Result<(), SrclistError> {
    match Args::from_args() {
        Args::Convert {
            input_source_list,
            output_source_list,
            input_type,
            output_type,
            verbosity,
        } => {
            setup_logging(verbosity).expect("Failed to initialize logging.");
            crate::convert(
                &input_source_list,
                &output_source_list,
                input_type,
                output_type,
            )?
        }

        Args::Verify {
            source_lists,
            verbosity,
        } => {
            setup_logging(verbosity).expect("Failed to initialize logging.");
            crate::verify(&source_lists)?;
        }
    }

    Ok(())
}
