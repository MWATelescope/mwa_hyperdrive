// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

//! Handle source list files.
//!
//! The executable generated by this file can verify that hyperdrive can read
//! source files, as well as convert between supported source list formats.

use std::path::PathBuf;

use structopt::{clap::AppSettings, StructOpt};

use mwa_hyperdrive_srclist::*;

#[derive(StructOpt, Debug)]
#[structopt(name = "hyperdrive srclist", author, about,
            global_settings = &[AppSettings::ColoredHelp,
                                AppSettings::ArgRequiredElseHelp])]
enum Args {
    /// Reduce a sky-model source list to the top N brightest sources, given
    /// pointing information.
    ///
    /// See for more info:
    /// https://github.com/MWATelescope/mwa_hyperdrive/wiki/Source-lists
    ByBeam {
        /// Path to the source list to be converted.
        #[structopt(name = "INPUT_SOURCE_LIST", parse(from_os_str))]
        input_source_list: PathBuf,

        /// Path to the output source list. If not specified, then then "_N" is
        /// appended to the filename.
        #[structopt(name = "OUTPUT_SOURCE_LIST", parse(from_os_str))]
        output_source_list: Option<PathBuf>,

        #[structopt(short = "i", long, parse(from_str), help = CONVERT_INPUT_TYPE_HELP.as_str())]
        input_type: Option<String>,

        #[structopt(short = "o", long, parse(from_str), help = CONVERT_OUTPUT_TYPE_HELP.as_str())]
        output_type: Option<String>,

        /// Reduce the input source list to the brightest N sources and write
        /// them to the output source list. If the input source list has less
        /// than N sources, then all sources are used.
        #[structopt(short = "n", long)]
        number: usize,

        /// Path to the metafits file.
        #[structopt(short = "m", long, parse(from_str))]
        metafits: PathBuf,

        #[structopt(long, help = SOURCE_DIST_CUTOFF_HELP.as_str())]
        source_dist_cutoff: Option<f64>,

        #[structopt(long, help = VETO_THRESHOLD_HELP.as_str())]
        veto_threshold: Option<f64>,

        /// Path to the MWA FEE beam file. If this is not specified, then the
        /// MWA_BEAM_FILE environment variable should contain the path.
        #[structopt(short, long)]
        beam_file: Option<PathBuf>,

        /// Attempt to convert flux density lists to power laws. See the online
        /// help for more information.
        #[structopt(short, long)]
        convert_lists: bool,

        /// Collapse all of the sky-model components into a single source; the
        /// apparently brightest source is used as the base source. This is
        /// suitable for an "RTS patch source list".
        #[structopt(long)]
        collapse_into_single_source: bool,

        /// The verbosity of the program. The default is to print high-level
        /// information.
        #[structopt(short, long, parse(from_occurrences))]
        verbosity: u8,
    },

    /// Convert a sky-model source list from one format to another.
    ///
    /// See for more info:
    /// https://github.com/MWATelescope/mwa_hyperdrive/wiki/Source-lists
    Convert {
        #[structopt(short = "i", long, parse(from_str), help = CONVERT_INPUT_TYPE_HELP.as_str())]
        input_type: Option<String>,

        /// Path to the source list to be converted.
        #[structopt(name = "INPUT_SOURCE_LIST", parse(from_os_str))]
        input_source_list: PathBuf,

        #[structopt(short = "o", long, parse(from_str), help = CONVERT_OUTPUT_TYPE_HELP.as_str())]
        output_type: Option<String>,

        /// Path to the output source list. If the file extension is .json or
        /// .yaml, then it will written in the hyperdrive source list format. If
        /// it is .txt, then the --output-type flag should be used to specify
        /// the type of source list to be written.
        #[structopt(name = "OUTPUT_SOURCE_LIST", parse(from_os_str))]
        output_source_list: PathBuf,

        /// Attempt to convert flux density lists to power laws. See the online
        /// help for more information.
        #[structopt(short, long)]
        convert_lists: bool,

        /// The verbosity of the program. The default is to print high-level
        /// information.
        #[structopt(short, long, parse(from_occurrences))]
        verbosity: u8,
    },

    /// Verify that sky-model source lists can be read by hyperdrive.
    ///
    /// See for more info:
    /// https://github.com/MWATelescope/mwa_hyperdrive/wiki/Source-lists
    Verify {
        /// Path to the source list(s) to be verified.
        #[structopt(name = "SOURCE_LISTS", parse(from_os_str))]
        source_lists: Vec<PathBuf>,

        /// The verbosity of the program. The default is to print high-level
        /// information.
        #[structopt(short, long, parse(from_occurrences))]
        verbosity: u8,
    },
}

fn setup_logging(level: u8) -> Result<(), fern::InitError> {
    fern::Dispatch::new()
        .format(|out, message, record| {
            out.finish(format_args!(
                "[{} line {}][{}] {}",
                record.target(),
                record.line().unwrap_or(0),
                record.level(),
                message
            ))
        })
        .level(match level {
            0 => log::LevelFilter::Info,
            1 => log::LevelFilter::Debug,
            _ => log::LevelFilter::Trace,
        })
        .chain(std::io::stdout())
        .apply()?;
    Ok(())
}

fn main() {
    // Stolen from BurntSushi. We don't return Result from main because it
    // prints the debug representation of the error. The code below prints the
    // "display" or human readable representation of the error.
    if let Err(e) = try_main() {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    }
}

fn try_main() -> Result<(), SrclistError> {
    match Args::from_args() {
        Args::ByBeam {
            input_source_list,
            output_source_list,
            input_type,
            output_type,
            number,
            metafits,
            source_dist_cutoff,
            veto_threshold,
            beam_file,
            convert_lists,
            collapse_into_single_source,
            verbosity,
        } => {
            setup_logging(verbosity).expect("Failed to initialize logging.");
            crate::by_beam(
                &input_source_list,
                output_source_list.as_ref(),
                input_type,
                output_type,
                number,
                &metafits,
                source_dist_cutoff,
                veto_threshold,
                beam_file.as_ref(),
                convert_lists,
                collapse_into_single_source,
            )?
        }

        Args::Convert {
            input_source_list,
            output_source_list,
            input_type,
            output_type,
            convert_lists,
            verbosity,
        } => {
            setup_logging(verbosity).expect("Failed to initialize logging.");
            crate::convert(
                &input_source_list,
                &output_source_list,
                input_type,
                output_type,
                convert_lists,
            )?
        }

        Args::Verify {
            source_lists,
            verbosity,
        } => {
            setup_logging(verbosity).expect("Failed to initialize logging.");
            crate::verify(&source_lists)?;
        }
    }

    Ok(())
}
